# [백준] 15649. N과 M (1)

[문제 보러가기](https://www.acmicpc.net/problem/15649)

🚩 `DFS`, `백트래킹`, `재귀함수`, `스택`

<br>

## 🅰 설계

for문을 돌면서 1부터 넣고 M개가 다 쌓이면 출력하는 걸로 생각했다.

그래서 출력할 리스트를 먼저 만들고 거기에 숫자를 넣으면서 방문체킹 리스트로 중복을 체킹한 후, 함수가 끝났으면 다시 원상복구하여 또 다른 경우를 찾는 걸로 생각했다.  ~~근데 이 과정이 어려웠다..~~

제한시간이 1초이기 때문에 가지치기를 해야할거 같았다. 최악의 경우, M = N = 8 이 되어 경우의 수가 8! = 40320 이기 때문이다.  ~~근데 딱히 쓸 필요가 없어서 안썼다..~~



## 초기 설정

출력할 리스트 `s` 와 방문체크를 할 `visited` 함수를 만들었다. 1~N까지라 인덱스 때문에 N+1까지 만들었고, 계속해서 동일한 과정을 반복하기 때문에 함수로 따로 빼주었다.

인자는 딱히 없어서 안 넣어줬다.

```python
N, M = map(int, input().split())  # N:주어진 수, M:수열의 길이
s = []  # 출력 수열 넣을 리스트 (stack)
visited = [False] * (N+1)  # 방문체크 할 리스트
DFS()  # 인자가 딱히 없어서 안넣음
```



## DFS 함수 구성

리스트의 길이가 M이 되면 M개의 숫자가 쌓였다는 의미이므로 출력 후 리턴하도록 해줬다.

어차피 for문이 순서대로 돌기 때문에 수열의 순서는 굳이 고려 안해도 됐다.

이미 방문했으면 건너뛰고, 방문 안했으면 방문 체크 한 후, 출력리스트에 넣고 다음 함수를 호출했다.

뭔가 맨 마지막 줄의 `visited[i] = False` 를 하면 무한의 루프에 빠질거 같아서 안해줬더니, 결과가 하나밖에 안나와서 해줬다...

```python
# 백트래킹 -> 재귀함수 사용
def DFS():
    if len(s) == M:
        print(*s)
        return

    for i in range(1, N+1):  # 1~N까지 숫자 순회하면서
        if visited[i]:  # 이미 방문했으면 패쓰
            continue

        # 방문 안했으면 방문체크 후, 출력 리스트에 넣음
        visited[i] = True
        s.append(i)
        DFS()  # 함수 다시 호출
        s.pop()  # 원상복귀 과정 필요
        visited[i] = False
```

<br><br>

## 🅱 최종 코드

### # 1.

> 방문체크로 푼 풀이

```python
# 백트래킹 -> 재귀함수 사용
def DFS():
    if len(s) == M:
        print(*s)
        return

    for i in range(1, N+1):  # 1~N까지 숫자 순회하면서
        if visited[i]:  # 이미 방문했으면 패쓰
            continue

        # 방문 안했으면 방문체크 후, 출력 리스트에 넣음
        visited[i] = True
        s.append(i)
        DFS()  # 함수 다시 호출
        s.pop()  # 원상복귀 과정 필요
        visited[i] = False


        
N, M = map(int, input().split())  # N:주어진 수, M:수열의 길이
s = []  # 출력 수열 넣을 리스트 (stack)
visited = [False] * (N+1)  # 방문체크 할 리스트
DFS()  # 인자가 딱히 없어서 안넣음..
```

<br>

### # 2.

> 방문체크 안하고 스택으로만 푼 풀이. 
>
> 방문체크와 방법 동일하되, 방문체크만 안해준 것임

```python
# 백트래킹 -> 재귀함수 사용
def DFS():
    if len(s) == M:
        print(*s)
        return

    for i in range(1, N+1):  # 1~N까지 숫자 순회하면서
        if i in s:  # 이미 리스트에 있으면 패쓰
            continue

        s.append(i)
        DFS()  # 함수 다시 호출
        s.pop()  # 원상복귀


        
N, M = map(int, input().split())  # N:주어진 수, M:수열의 길이
s = []  # 출력 수열 넣을 리스트 (stack)
DFS()
```

 <br><br>

## ✅ 후기

### 새롭게 알게 된 점

- 처음에는 당연히 방문체킹해야지라고 생각하고 아무생각 없이 visited 리스트 만들었는데 코드를 돌려보니 어차피 1부터 차례대로 돌아서 상관없었다. 
- 또한, 스택에 넣었다 뺐다 하면서 이미 스택에 있는 경우를 건너뛰기 때문에 굳이 방문체킹을 안해도 된다는 점이 신기했다.

### 어려웠던 점

- 함수 return이 너무 헷갈린다.

- 처음 풀었을 때는 빈 리스트로 만들어서 해당하는 경우를 전부 리스트에 넣고 그 리스트를 반환하는 걸 생각했는데, `None` 이 리턴되는걸 보고 식겁하며 포기했다,, 함수가 리턴되고도 그 밑에 `pop` 과 `visited = False` 를 해줘서 리스트를 리턴하면 안되는 것 같다.