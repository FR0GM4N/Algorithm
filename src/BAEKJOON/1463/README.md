# 1463번 1로 만들기

[문제 보러가기](https://www.acmicpc.net/problem/1463)

🚩 `동적프로그래밍`

<br>

## 🅰 설계

1. 시간제한이 1.5초라서 모든 경우를 다 구하고 거기서 최소를 찾는건 아닌거 같음.

<br>

2. 일단 규칙이 있나 찾아보자
   - 2, 3을 갖고 있으면 일단 나누기 (2, 3의 지수의 합이 답)
   - but, 10의 경우 위에 처럼 구하면 2x5 => `4` 인데,  -1하면 3²이라 => `3` 이 답이 됨...
   - 3으로 나눈 나머지가 1이면 먼저 -1을 하고 계산을 해볼까 ?
     - 짝수 & 3의 배수와 1차이 나는 것들
       - 10 -> 9 -> 3 -> 1 => `3`  or  10 -> 5 -> 4 -> 2 -> 1 => `4`   👉 -1 & /3  (2x5)
       - 16 -> 15 -> 5 -> 4 -> 2 -> 1 => `5`   or  16 -> 2⁴ => `4`   👉 /2  (2⁴)
       - 22 -> 21 -> 7 -> 6 -> 2 -> 1 => `5`   or   22 -> 11-> 10 -> 9 -> 3 -> 1 => `5`  👉 똑같음 (2x11)
       - 40 -> 39 -> 13 -> 12=2²x3 => `6`   or  40 -> 20 -> 10 -> 9=3² => `5`  👉 /2  (2³x5)
       - 👉 장난하나... 다 달라....
     - 홀수 & 3의 배수와 1차이 나는 것들 -> 무조건 1빼고 시작할 수 밖에 없음
       - 13 -> 12 -> 6 -> 2-> 1 => `4`
       - 19 -> 18 -> 6 -> 2 -> 1 => `4`  or  19 -> 18 -> 9 -> 3 -> 1 = `4`  (∵ 18 = 2¹x3² => `3` )
       - 25 -> 24 -> 11 -> 10 -> 9 -> 3 -> 1 => `6`  or  25 -> 24 -> 8 -> 4 -> 2 -> 1 => `5`
       - 👉 -1 & /3
   - 짝수 & 3의 배수와 2 차이 나는 것들
     - 20 -> 10 -> 9 -> 3 -> 1 => `4`  or  20 -> 19 -> 18 -> 6 -> 2 -> 1 => `5`  👉 /2
     - 26 -> 13 -> 12 = 2²x3 => `5`   or  26 -> 25 -> 24 = 2³x3 => `6`  👉 /2
   - 홀수 & 3의 배수와 2 차이나는 것들 -> 1빼면 짝수됨
     - 11 -> 10 -> 9 -> 3 -> 1 => `4`  👉 -2 & /3
     - 17 -> 16 -> 8 -> 4 -> 2 -> 1 => `5`  or  17 -> 16 -> 15 -> 5 -> 4 -> 2 -> 1 => `6` 👉 -1 & /2
     - 23 -> 22 -> 11 -> 10 => `6`  or  23 -> 22 -> 21 -> 7 -> 6 -> 2 -> 1 => `6`
     - 👉 규칙없음 ;;

이런식으로 없는 규칙이지만 꾸역꾸역 구했을 때, 대충 답은 맞게 나오는거 같은데 백준에서 코드 돌려보면 틀렸다고 떴다.. 당연한 결과.. 

```python
T = int(input())

#  /3 먼저
def find1(N):
    global cnt1
    if N == 1:
        return

    if N % 3 == 0:
        N //= 3
        cnt1 += 1
    elif N % 3 == 1:
        N -= 1
        cnt1 += 1
    elif N % 2 == 0:
        N //= 2
        cnt1 += 1
    else:
        N -= 1
        cnt1 += 1
    find1(N)

# /2 먼저
def find2(N):
    global cnt2
    if N == 1:
        return

    if N % 2 == 0:
        N //= 2
        cnt2 += 1
        if N == 10:  # 말도안되는 조건 넣기..ㅋ
            cnt2 += 3
            return
    elif N % 3 == 0:
        N //= 3
        cnt2 += 1
    else:
        N -= 1
        cnt2 += 1
    find2(N)


for tc in range(1, T+1):
    N = int(input())
    res = []
    cnt1, cnt2 = 0, 0

    find1(N)
    find2(N)
    res.append(cnt1)
    res.append(cnt2)
    print("숫자:{} 결과:{}".format(N, min(res)))
```

<br>

이 문제가 규칙찾기는 아닌거 같은데 어떻게 풀어야할까..

3. 결국 모르겠어서 구글링했다.

이 문제는 가장 기본적인 DP 문제라고 한다.

- **점화식 : dp(N) = min ( dp(N//3)+1, dp(N//2)+1 , dp(N-1)+1 )**

인풋숫자의 크기만큼 배열을 만들고, 계산횟수를 해당 인덱스에 입력 & 비교하면서 최소 연산값을 구하는 것이다.

앞에서 부터 계산을 해가면서 카운팅을 늘려나가는 것이 핵심이다 ! 

(뒤에서부터 따지면 위에 규칙찾기처럼 1도 모르기 때문)

- **시간복잡도 :  {배열의 크기 x O(1)} => O(N)**

<br>

## 🅱 최종 코드

```python
N = int(input())

dp = [0 for _ in range(N+1)]  # 인덱스가 N이 되도록 N+1 크기의 배열을 만듦

for i in range(2, N+1):
    dp[i] = dp[i-1] + 1  # dp(N-1)+1 계산먼저 해주고

    if i % 2 == 0 and dp[i] > dp[i//2] + 1:  # 2로 나눠지면서 카운팅횟수가 전보다 크면 바꾸기
        dp[i] = dp[i//2] + 1

    if i % 3 == 0 and dp[i] > dp[i//3] + 1:  # 3으로 나눠지면서 카운팅횟수가 전보다 크면 바꾸기
        dp[i] = dp[i//3] + 1

print(dp[N])  # 가장 마지막의 끝 인덱스(자기자신)를 구하면 된다.== print(dp[-1])
```



```python
# N = 10 인 경우 dp 배열
[0, 0, 1, 1, 2, 3, 2, 3, 3, 2, 3]
```

<br>

## ✅ 후기

### 새롭게 알게 된 점

이런 유형의 문제 해결법 - 앞에서부터 계산하는 방법 기억할 것 & 점화식

### 어려웠던 점

1. 초반에 규칙이 정말 안찾아졌음 <- 규칙으로 푸는 문제가 아니니까 당연

2. DP로 풀어야겠다는 생각은 했는데 방법을 몰랐음